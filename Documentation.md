##Пользовательская документация к проекту:


#«Библиотека 2d графики для растровых изображений формата bmp»

================

###Автор: Евтеева А.В.

###Группа 4103, ФНБИК

###2016 год

-------------

##Содержание:

###1.	Цель проекта
###2.	Общие сведения о растровых изображениях и формате bmp
###3.	Реализация библиотеки
###•	 Описание используемых структур
###•	Описание реализации функций
####        - Фильтры
####        - Отражения
####     - Увеличения/уменьшения
####        - Поворот на 90 градусов
###3.Применение
###4.Список литературы

--------------------------------------------------------------------------------------------------------------------------

###1.Цель проекта
Целью данной работы было создание библиотеки, которая позволяет работать с растровыми изображениями формата bmp. Пользователь, подключив данную библиотеку к своей программе, имеет возможность использовать следующие функции: загружать и сохранять изображение, применять различные фильтры к изображению, отражать его зеркально, вертикально или горизонтально, увеличивать/ уменьшать изображение, а также поворачивать его.














----------
###2. Общие сведения о растровых изображениях
Растровое изображение — изображение, представляющее собой сетку пикселей — цветных точек (обычно прямоугольных) на мониторе, бумаге и других отображающих устройствах.
BMP (Bitmap Picture) — формат хранения растровых изображений, разработанный компанией Microsoft. Файлы формата BMP могут иметь расширения .bmp, .dib и .rle.
С форматом BMP работает огромное количество программ, так как его поддержка интегрирована в операционные системы Windows и OS/2. Кроме того, данные этого формата включаются в двоичные файлы ресурсов RES и в PE-файлы.
В данном формате можно хранить только однослойные растры. На каждый пиксель в разных файлах может приходиться разное количество бит (глубина цвета). Microsoft предлагает битности 1, 2, 4, 8, 16, 24, 32, 48 и 64. В битностях 8 и ниже он указывается индексом из таблицы цветов (палитры), а при больших непосредственным значением. Цвет же в любом случае можно задать только в цветовой модели RGB (как при непосредственном указании в пикселе, так и в таблице цветов), но в битностях 16 и 32 можно получить Grayscale с глубиной до 16 и 32 бит соответственно. Частичная прозрачность реализована альфа-каналом различных битностей, но при этом прозрачность без градаций можно косвенно получить RLE-кодированием.

В большинстве случаев пиксели хранятся в виде относительно простого двумерного массива. Для битностей 4 и 8 доступно RLE-кодирование, которое может уменьшить их размер. Формат BMP также поддерживает встраивание данных в форматах JPEG и PNG. Но последнее скорее больше предназначено не для компактного хранения, а для обхода ограничений архитектуры GDI, которая не предусматривает прямую работу с изображениями отличных от BMP форматов.

В последних версиях формата BMP также появились возможности по управлению цветом. В частности, можно указывать конечные точки, производить гамма-коррекцию и встраивать цветовые профили ICC.










----------
###3. Структура библиотеки
Библиотека написана на языке С++.
####Используемые структуры:
Структура RGBTRIPLE, объявленная в windows.h, описывает цвет, состоящий из относительных интенсивностей красного, зеленого и синего цвета.
######typedef struct tagRGBTRIPLE { 
######  BYTE rgbtBlue; 
######  BYTE rgbtGreen; 
######  BYTE rgbtRed; 
######} RGBTRIPLE; 

Структура BIH(BITMAPINFOHEADER) содержит информацию о размерах и цветовом формате аппаратно-независимого растрового формата.
typedef struct tagBITMAPINFOHEADER{
######      int    biSize;                      // размер струкуры в байтах:
######                                          // 40(BITMAPINFOHEADER) или                         
######                                          //108(BITMAPV4HEADER)  или 124 (BITMAPV5HEADER)
######      int    biWidth;                // ширина в точках
######      int    biHeight;               // высота в точках
######      WORD   biPlanes;         // всегда должно быть 1
######      WORD   biBitCount;     // 0 | 1 | 4 | 8 | 16 | 24 | 32
######      int    biCompression;   // BI_RGB | BI_RLE8 | BI_RLE4 |
######                                              // BI_BITFIELDS | BI_JPEG | BI_PNG
######                                              // реально используется лишь BI_RGB
######      int    biSizeImage;        // Количество байт в поле данных
######                                             // Обычно устанавливается в 0
######      int    biXPelsPerMeter;// горизонтальное разрешение, точек на дюйм
######      int    biYPelsPerMeter;// вертикальное разрешение, точек на дюйм
######      int    biClrUsed;            // Количество используемых цветов
######                                             // (если есть таблица цветов)
######      int    biClrImportant; // Количество существенных цветов.
######                                            // Можно считать, просто 0
######} BITMAPINFOHEADER;
Структура BFH(BITMAPFILEHEADER) содержит информацию о размерах и цветовом формате аппаратно-независимого растрового рисунка.


######typedef struct tagBITMAPFILEHEADER
######{ WORD   bfType;          // 0x4d42 | 0x4349 | 0x5450
######      int    bfSize;               // размер файла
######      int    bfReserved;     // 0
######      int    bfOffBits;      // смещение до поля данных,
######                             // обычно 54 = 16 + biSize
######} BITMAPFILEHEADER;

---------------









































###Реализация функций:

####	Фильтры
В данном проекте мы реализовывали фильтры с помощью матрицы свертки.
Матрица свёртки – это матрица коэффициентов, которая «умножается» на значение пикселей изображения для получения требуемого результата.
div – это коэффициент нормирования, для того чтобы средняя интенсивность оставалась не изменой.
Программно это реализовывалось так: мы заполняем матрицу neighbors размера 3 на 3, используя «соседей» пикселя. 
Далее эту матрицу умножаем на матрицу свертки matrix по следующему правилу ∑neighbors[i][j]*matrix[i][j].
Делим получившееся число на нормировочный коэффициент и в результате получаем новое значение цвета пикселя.
#####Фильтр размытия
Наиболее часто используемым фильтром, основанным на матрице свёртки, является фильтр размытия.
Обычно матрица заполняется по нормальному (гауссовому закону).
В данной библиотеке для размытия мы использовали следующую матрицу:
#####1	2	1
#####2	4	2
#####1	2	1
---
#####Фильтр улучшения чёткости
#####-1	-1	- 1 
#####-1	9	-1
#####-1	-1	-1

---
#####Фильтр увеличения яркости
     
#####-0,1	0,2	-0,1
#####0,2	3	0,2
#####-0,1	0,2	0,1
---
####Фильтр затемнения 
#####-0,1	0,1	-0,1
#####0,1	0,5	0,1
#####-0,1	0,1	0,1 
---
#####RGBTRIPLE* matrixConvolution(RGBTRIPLE *v, int mx, int my, double matrix[3][3], int div);

Функция возвращает новый массив пикселей.
RGBTRIPLE *v-первоначальный массив пиксилей
int mx, int my-ширина и длина изображения
double matrix[3][3]-матрица свертки
int div-нормировочный коэффициент

---------------
































####Отражения

#####Горизонтальное
Мы создаем новую матрицу и заполняем ее по следующему правилу: каждому пикселю с координатами (x,y) мы присваиваем значение (x,my-y), где my – длинна картинки

#####Вертикальное
Аналогично. (x,y) присваиваем значение (mx-x,y)

#####Вертикальное и горизонтальное
Аналогично. (x,y) присваиваем (mx-x,my-y)

Функция возвращает новый массив пикселей.

#####RGBTRIPLE* reflectionX(RGBTRIPLE *v, int mx, int my);
#####RGBTRIPLE* reflectionY(RGBTRIPLE *v, int mx, int my);
#####RGBTRIPLE* reflectionXY(RGBTRIPLE *v, int mx, int my);

RGBTRIPLE *v-первоначальный массив пиксилей
int mx, int my-ширина и длина изображения

---------------



















####Увеличения/уменьшения изображения

Для каждого пикселя с координатами (x,y) в изображении «заполняем квадрат» ширины  x1*x, длины y1*y

######RGBTRIPLE* ex(RGBTRIPLE *v, int &mx, int &my, float x1, float y1);

Функция возвращает новый массив пикселей.

RGBTRIPLE *v-первоначальный массив пиксилей
int mx, int my-ширина и длина изображения
float x1- на сколько увеличить/уменьшить в ширину
float y1- на сколько увеличить/ уменьшить в длину


---------------


















####Поворот на 90 градусов
Функция поворота на 90 градусов сопоставляет вектору с координатами (x,y)->(y,-x). 
И нам надо ещё сдвинуть матрицу на новую ширину массива, т.е. (x,y)->(y,my-x).

#####RGBTRIPLE* rott(RGBTRIPLE *v, int &mx, int &my);

Функция возвращает новый массив пикселей.

RGBTRIPLE *v-первоначальный массив пиксилей
int mx, int my-ширина и длина изображения

---------------




















####Применение 

Как уже было сказано выше данную библиотеку можно применять в различных программах для работы с растровыми изображениями данного типа. Так, функции данной библиотеки были с успехом использованы Анной Гладких в растровом редакторе.

---------------















































#### Литература
https://ru.wikipedia.org/wiki/BMP#BITMAPFILEHEADER
http://math.ivanovo.ac.ru/dalgebra/Khashin/gr/bmp/bmp.html
https://habrahabr.ru/post/142818/

